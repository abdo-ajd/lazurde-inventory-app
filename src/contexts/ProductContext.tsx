
// src/contexts/ProductContext.tsx
"use client";

import type { Product } from '@/lib/types';
import { createContext, useContext, ReactNode, useCallback } from 'react';
import { useLocalStorage } from '@/hooks/useLocalStorage';
import { LOCALSTORAGE_KEYS, INITIAL_PRODUCTS } from '@/lib/constants';
import { useToast } from '@/hooks/use-toast';

type ProductUpdatePayload = Partial<Pick<Product, "name" | "price" | "quantity" | "imageUrl" | "barcodeValue">>;

interface ProductContextType {
  products: Product[];
  addProduct: (productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Product | null>;
  updateProduct: (productId: string, updates: ProductUpdatePayload) => Promise<Product | null>;
  deleteProduct: (productId: string) => Promise<boolean>;
  getProductById: (productId: string) => Product | undefined;
  getProductByBarcode: (barcodeValue: string) => Product | undefined;
  updateProductQuantity: (productId: string, quantityChange: number) => Promise<boolean>;
  replaceAllProducts: (newProducts: Product[]) => void;
}

const ProductContext = createContext<ProductContextType | undefined>(undefined);

export const ProductProvider = ({ children }: { children: ReactNode }) => {
  const initialProductsCreator = useCallback(() => INITIAL_PRODUCTS, []);
  const [products, setProducts] = useLocalStorage<Product[]>(LOCALSTORAGE_KEYS.PRODUCTS, initialProductsCreator);
  const { toast } = useToast();

  const addProduct = async (productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product | null> => {
    const currentProducts = products || [];

    if (currentProducts.find(p => p.name.trim().toLowerCase() === productData.name.trim().toLowerCase())) {
      toast({ title: "خطأ", description: "منتج بنفس الاسم موجود بالفعل.", variant: "destructive" });
      return null;
    }
    
    const productIdTimestamp = Date.now();
    const generatedProductId = `prod_${productIdTimestamp}`;
    
    let autoGeneratedBarcodeValue = String(productIdTimestamp); // Default to timestamp
    if (productData.barcodeValue && productData.barcodeValue.trim() !== '') {
      autoGeneratedBarcodeValue = productData.barcodeValue.trim();
    }

    const newProductToAdd: Product = {
      ...productData,
      id: generatedProductId,
      imageUrl: productData.imageUrl || '', // Ensure imageUrl is at least an empty string
      barcodeValue: autoGeneratedBarcodeValue, // Ensure barcodeValue is set
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    try {
      setProducts(prevProducts => {
        const updatedList = [...(prevProducts || []), newProductToAdd];
        return updatedList;
      });
      toast({ title: "نجاح", description: `تمت إضافة المنتج "${newProductToAdd.name}" بنجاح.` });
      return newProductToAdd;
    } catch (error) {
      console.error("Failed to add product:", error);
      toast({ title: "خطأ في الإضافة", description: "لم يتم حفظ المنتج بسبب خطأ.", variant: "destructive" });
      return null;
    }
  };

  const updateProduct = async (productId: string, updates: ProductUpdatePayload): Promise<Product | null> => {
    let productToUpdate = (products || []).find(p => p.id === productId);

    if (!productToUpdate) {
      toast({ title: "خطأ", description: "المنتج غير موجود لتحديثه.", variant: "destructive" });
      return null;
    }

    // Check for name conflict if name is being updated and is different from original
    if (updates.name && updates.name.trim().toLowerCase() !== productToUpdate.name.trim().toLowerCase()) {
      if ((products || []).some(p => p.id !== productId && p.name.trim().toLowerCase() === updates.name!.trim().toLowerCase())) {
        toast({ title: "خطأ", description: "منتج آخر بنفس الاسم الجديد موجود بالفعل.", variant: "destructive" });
        return productToUpdate; // Return original product as no update was made
      }
    }
    
    let successfullyUpdatedProduct: Product | null = null;

    try {
      setProducts(prevProducts => {
        return (prevProducts || []).map(p => {
          if (p.id === productId) {
            successfullyUpdatedProduct = {
              ...p,
              name: updates.name !== undefined ? updates.name : p.name,
              price: updates.price !== undefined ? updates.price : p.price,
              quantity: updates.quantity !== undefined ? updates.quantity : p.quantity,
              imageUrl: updates.imageUrl !== undefined ? (updates.imageUrl || '') : p.imageUrl,
              barcodeValue: updates.barcodeValue !== undefined ? (updates.barcodeValue || '') : p.barcodeValue,
              updatedAt: new Date().toISOString(),
            };
            return successfullyUpdatedProduct;
          }
          return p;
        });
      });

      if (successfullyUpdatedProduct) {
        // Check if a meaningful change occurred for the toast
        const originalProduct = productToUpdate; // For comparison
        const meaningfulChange = 
            updates.name !== undefined && updates.name !== originalProduct.name ||
            updates.price !== undefined && updates.price !== originalProduct.price ||
            updates.quantity !== undefined && updates.quantity !== originalProduct.quantity ||
            (updates.imageUrl !== undefined && updates.imageUrl !== originalProduct.imageUrl) ||
            (updates.barcodeValue !== undefined && updates.barcodeValue !== originalProduct.barcodeValue);

        if (meaningfulChange) {
             toast({ title: "نجاح", description: `تم تحديث المنتج "${successfullyUpdatedProduct.name}".` });
        } else if (originalProduct.updatedAt !== successfullyUpdatedProduct.updatedAt) {
            // This case could happen if only image was "cleared" to empty or barcode was "cleared"
            // or if no actual value changed but form was submitted.
            // For simplicity, any successful save operation leading to a new updatedAt might show a generic success.
            // Or, we can be more specific:
            if (updates.imageUrl === '' && originalProduct.imageUrl !== '' || updates.barcodeValue === '' && originalProduct.barcodeValue !== '') {
                 toast({ title: "نجاح", description: `تم تحديث المنتج "${successfullyUpdatedProduct.name}".` });
            } else if (!meaningfulChange) {
                // No actual field changed its value, but updatedAt did.
                // Optionally, don't show toast or show a "No changes detected" toast.
                // For now, let's assume any save is a "success" if it goes through.
                 toast({ title: "نجاح", description: `تم حفظ التغييرات للمنتج "${successfullyUpdatedProduct.name}".` });
            }
        }
        return successfullyUpdatedProduct;
      } else {
        // This should not happen if productToUpdate was found
        throw new Error("Update logic failed to produce an updated product instance.");
      }
    } catch (error) {
        console.error("Failed to update product:", error);
        toast({ title: "خطأ في التحديث", description: "لم يتم حفظ التعديلات بسبب خطأ.", variant: "destructive" });
        return productToUpdate; // Return original product on error
    }
  };

  const deleteProduct = async (productId: string): Promise<boolean> => {
    const productToDelete = (products || []).find(p => p.id === productId);
    if (!productToDelete) {
      toast({ title: "خطأ", description: "المنتج غير موجود.", variant: "destructive" });
      return false;
    }
    try {
      setProducts(prevProducts => (prevProducts || []).filter(p => p.id !== productId));
      // Toast for delete is handled in the component calling deleteProduct after success.
      return true;
    } catch (error) {
      console.error("Failed to delete product:", error);
      toast({ title: "خطأ في الحذف", description: "لم يتم حذف المنتج بسبب خطأ.", variant: "destructive" });
      return false;
    }
  };

  const getProductById = (productId: string): Product | undefined => {
    return (products || []).find(p => p.id === productId);
  };

  const getProductByBarcode = (barcodeValue: string): Product | undefined => {
    return (products || []).find(p => p.barcodeValue === barcodeValue);
  };

  const updateProductQuantity = async (productId: string, quantityChange: number): Promise<boolean> => {
    const product = getProductById(productId);
    if (!product) {
      return false;
    }
    const newQuantity = product.quantity + quantityChange;
    if (newQuantity < 0) {
      return false;
    }
    
    const result = await updateProduct(productId, { quantity: newQuantity });
    return !!result;
  };

  const replaceAllProducts = (newProducts: Product[]): void => {
    try {
      setProducts(newProducts);
    } catch (error) {
      console.error("Failed to replace all products:", error);
      toast({ title: "خطأ", description: "فشل استعادة بيانات المنتجات.", variant: "destructive" });
    }
  };

  return (
    <ProductContext.Provider value={{ products: products || [], addProduct, updateProduct, deleteProduct, getProductById, getProductByBarcode, updateProductQuantity, replaceAllProducts }}>
      {children}
    </ProductContext.Provider>
  );
};

export const useProducts = () => {
  const context = useContext(ProductContext);
  if (context === undefined) {
    throw new Error('useProducts must be used within a ProductProvider');
  }
  return context;
};
